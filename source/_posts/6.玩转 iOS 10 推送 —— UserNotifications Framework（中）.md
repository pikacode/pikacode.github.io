---
title: 玩转 iOS 10 推送 —— UserNotifications Framework（中）
date: 2016.09.21 17:37
tags: [Push Notification, iOS 10]
categories: [Push Notification, iOS 10]
---

[上一篇](http://www.jianshu.com/p/2f3202b5e758) 咱们聊了一些：

- iOS 10 before 推送的流程
- iOS 10 beta 推送的基本使用方法
- 以及跟 iOS 10 before 推送的区别

这一篇咱们将继续探讨 iOS 10 推送，并向大家介绍一些进阶的内容。

#### Notification Actions
在 iOS 10 中，可以允许推送添加交互操作 `action`，这些 `action` 可以使得 App 在前台或后台执行一些逻辑代码。并且在锁屏界面通过 3d-touch 触发。如：推出键盘进行快捷回复，该功能以往只在 iMessage 中可行。
（Notification Actions 在 iOS 8 引入，快捷回复在 iOS 9 引入，在 iOS 10 中，这些 API 被统一。）
![](http://upload-images.jianshu.io/upload_images/1944178-ea5293c4be0c0775.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

在 iOS 10 中，这叫 `category`，是对推送功能的一个拓展，可以通过 3d-touch 触发。

1. 创建 `action`

   - 即一项交互操作

   - `title` 是交互按钮的内容

   - `options` 可以让该 `action` 成为一条可在前台执行的 `action`

   - 创建：

     ```objc
     UNNotificationAction *action = [UNNotificationAction actionWithIdentifier:@"reply" title:@"Reply" options:UNNotificationActionOptionNone];
     ```

2. 创建 `category`

   - 可添加多个 `action` 的数组，就像图片中一样，有多种操作

   - 其中的 `id`，需要填写你想要添加到哪个推送消息的 `id`

   - 创建：

     ```objc
     UNNotificationCategory *category = [UNNotificationCategory categoryWithIdentifier:@"message" actions:@[action] minimalActions:@[action] intentIdentifiers:@[] options:UNNotificationCategoryOptionNone];
     ```

3. 把 `category` 添加到通知中心：

   ```objc
   [[UNUserNotificationCenter currentNotificationCenter] setNotificationCategories:[NSSet setWithArray:@[category]]];
   ```

4. 触发方式：

   - Remote Notifications 配置 payload，指定其中 category 的值与第 2 步中 Identifier 一致：

     ```objc
     {
       aps : {
       alert : "Welcome to WWDC !",
       category : "message"
       		}
     }
     ```

   - Local Notifications 只需要在创建 contnet 的时候指定 Id 即可：（content 相关内容请参照 [上一篇](http://www.jianshu.com/p/2f3202b5e758) 中的 Content 部分）

     ```objc
     content。categoryIdentifier = @"message";
     ```

     ​

#### Dismiss Actions

锁屏及在通知中心收到推送，侧滑，会展示 action。

只要点击 Clear 就可以将该条推送清除，并且重复的内容不会被发送到你的其他 iOS 设备上。

![](http://upload-images.jianshu.io/upload_images/1944178-3ebc9b53bcf6dc5c.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![](http://upload-images.jianshu.io/upload_images/1944178-68b7a8edd4ff5d27.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

跟 Notification Actions 只有一点小区别，就是添加 action 到 category 的时候，增加一个 option 的值 UNNotificationCategoryOptionCustomDismissAction：

```objc
UNNotificationAction *clearAction = [UNNotificationAction actionWithIdentifier:@"clear" title:@"clear" options:UNNotificationActionOptionNone];

UNNotificationCategory *category = [UNNotificationCategory categoryWithIdentifier:@"clear" actions:@[clearAction] intentIdentifiers:@[] options:UNNotificationCategoryOptionCustomDismissAction];//这里增加一个 dismiss 的值
```

#### Response handling

用户点击这些 actions 以后，是启动 App、触发键盘、清除通知或是有其他的响应，这些全部只需要实现协议 UNUserNotificationCenterDelegate 中的一个方法就可以控制：

```objc
@interface ClassName () <UNUserNotificationCenterDelegate>
-(void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)())completionHandler{

}
```

其中的 response 包含以下内容：

![](http://upload-images.jianshu.io/upload_images/1944178-3d0b1ae110343d65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

其中的 trigger 可以用来判断是远程推送还是本地推送。

处理 response 举例：

```objc
-(void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)())completionHandler{

    NSString *categoryIdentifier = response.notification.request.content.categoryIdentifier;

    if ([categoryIdentifier isEqualToString:@"handle category"]) {//识别需要被处理的拓展

        if ([response.actionIdentifier isEqualToString:@"input text"]) {//识别用户点击的是哪个 action

            //假设点击了输入内容的 UNTextInputNotificationAction 把 response 强转类型
            UNTextInputNotificationResponse *textResponse = (UNTextInputNotificationResponse*)response;
          	//获取输入内容
            NSString *userText = textResponse.userText;
            //发送 userText 给需要接收的方法
            [ClassName handleUserText: userText];
        }else{

        }

    }
    completionHandler();
}
```



### Service Extension

---

可以在手机「接收到推送之后、展示推送之前」对推送进行处理，更改、替换原有的内容。

使用了这个玩意，你们公司原有发送推送的 payload 可以完全不变，而在客户端对接收到的内容（只有一条字符串）进行加工，从而适配 iOS 10 的展示效果（标题+副标题+内容）。

![](http://upload-images.jianshu.io/upload_images/1944178-79647eddbe73b84f.gif?imageMogr2/auto-orient/strip)



##### 「接收到推送之后、展示推送之前」：

- 此时，你获得了一小段在后台运行代码的时间（也可以用来干别的坏事>。<，可以偷偷的断点下载你们 App 的更新包）
- 而如果你更改推送内容出了错误，或者你调用什么方法失败了，那么最终会正常的展示最初接收到的推送内容。

#### Potential uses

值得你们 App 充分发挥的是可以做以下事情：

- 端到端加密
- 给推送展示内容添加附件（比如照片、背景音乐），使得内容更加丰富，就像从推送里拉出了一个网页有木有！



不急，我们先来介绍怎么

##### 添加 Service Extension

先在 Xcode 打开你的 App 工程，File - New - Target 然后添加这个：

![](http://upload-images.jianshu.io/upload_images/1944178-df0f0b9054c38994.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

然后会自动创建一个 UNNotificationServiceExtension 的子类 NotificationService，通过完善这个子类，来实现你的需求。

点开 NotificationService.m 会看到 2 个方法：

```objc
- (void)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(void (^)(UNNotificationContent * _Nonnull))contentHandler {
    self.contentHandler = contentHandler;
    self.bestAttemptContent = [request.content mutableCopy];
    
    self.bestAttemptContent.title = [NSString stringWithFormat:@"%@ [modified]", self.bestAttemptContent.title];
    
    self.contentHandler(self.bestAttemptContent);
}

- (void)serviceExtensionTimeWillExpire {
    self.contentHandler(self.bestAttemptContent);
}
```

- didReceiveNotificationRequest 让你可以在后台处理接收到的推送，传递最终的内容给 contentHandler
- serviceExtensionTimeWillExpire 在你获得的一小段运行代码的时间即将结束的时候，如果仍然没有成功的传入内容，会走到这个方法，可以在这里传肯定不会出错的内容，或者他会默认传递原始的推送内容

##### Example payload

```json
{
  aps : {
    alert : "New Message",
    mutable-content : 1
  },
  encrypted-content : "#myencryptedcontent"
}
```

首先需要添加 mutable-content : 1，这意味着此条推送可以被 Service Extension 进行更改

同时可以附加一条 encrypted-content，可以提取该内容进行替换

```objc
- (void)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(void (^)(UNNotificationContent * _Nonnull))contentHandler {

    //用你的重编码方法对该内容进行更改
    NSString *decryptedBody = [DecryptClass decrypt: request.content.userInfo[@"encrypted-content"]];

    //创建新的 content 并添加修改过的 body
    UNMutableNotificationContent *newContent = [UNMutableNotificationContent new];

    newContent.body = decryptedBody;

    //回调新的 content
    contentHandler(newContent);
}
```
